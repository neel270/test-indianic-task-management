import { UserEntity } from '../../domain/entities';
import { IUserRepository, UserFilters } from '../../domain/repositories/user.repository';
import { Email } from '../../domain/value-objects/email.vo';

export interface PaginatedUsersResult {
  users: UserEntity[];
  pagination: {
    total: number;
    page: number;
    limit: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
    totalItems: number;
  };
}

export interface UserStats {
  totalUsers: number;
  activeUsers: number;
  inactiveUsers: number;
  adminUsers: number;
  regularUsers: number;
}

export class UserService {
  constructor(private readonly userRepository: IUserRepository) {}

  async createUser(
    name: string,
    email: string,
    password: string,
    role: 'admin' | 'user' = 'user'
  ): Promise<UserEntity> {
    // Check if user with email already exists
    const emailVo = Email.create(email);
    const existingUser = await this.userRepository.findByEmail(emailVo);
    if (existingUser) {
      throw new Error('User with this email already exists');
    }

    // Split name into first and last name
    const nameParts = name.trim().split(' ');
    const firstName = nameParts[0] || '';
    const lastName = nameParts.slice(1).join(' ') || '';

    // Create user entity
    const user = new UserEntity(
      '', // ID will be generated by the repository
      firstName,
      lastName,
      email,
      password,
      role,
      true // isActive
    );

    // Save user
    return await this.userRepository.save(user);
  }

  async getUserById(userId: string): Promise<UserEntity> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new Error('User not found');
    }
    return user;
  }

  async getUserByEmail(email: string): Promise<UserEntity> {
    const emailVo = Email.create(email);
    const user = await this.userRepository.findByEmail(emailVo);
    if (!user) {
      throw new Error('User not found');
    }
    return user;
  }

  async getAllUsers(
    page: number = 1,
    limit: number = 10,
    _filters?: UserFilters
  ): Promise<PaginatedUsersResult> {
    const result = await this.userRepository.findAll(page, limit);
    const totalPages = Math.ceil(result.total / limit);

    return {
      ...result,
      pagination: {
        total: result.total,
        page,
        limit,
        totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1,
        totalItems: result.total,
      },
    };
  }

  async updateUser(
    userId: string,
    updates: {
      name?: string;
      email?: string;
      role?: 'admin' | 'user';
      isActive?: boolean;
    }
  ): Promise<UserEntity> {
    const existingUser = await this.userRepository.findById(userId);
    if (!existingUser) {
      throw new Error('User not found');
    }

    // If email is being updated, check if new email already exists
    if (updates.email && updates.email !== existingUser.email) {
      const emailVo = Email.create(updates.email);
      const userWithEmail = await this.userRepository.findByEmail(emailVo);
      if (userWithEmail) {
        throw new Error('User with this email already exists');
      }
    }

    // Update user entity
    const updatedUser = existingUser.updateDetails({
      name: updates.name,
      email: updates.email,
      role: updates.role,
      isActive: updates.isActive,
    });

    return await this.userRepository.update(userId, updatedUser);
  }

  async deleteUser(userId: string): Promise<boolean> {
    const existingUser = await this.userRepository.findById(userId);
    if (!existingUser) {
      throw new Error('User not found');
    }

    return await this.userRepository.delete(userId);
  }

  async toggleUserStatus(userId: string): Promise<UserEntity> {
    const existingUser = await this.userRepository.findById(userId);
    if (!existingUser) {
      throw new Error('User not found');
    }

    // Toggle the active status
    const updatedUser = existingUser.updateDetails({
      isActive: !existingUser.isActive,
    });

    return await this.userRepository.update(userId, updatedUser);
  }

  async getUsersByRole(role: 'admin' | 'user'): Promise<UserEntity[]> {
    return await this.userRepository.findByRole(role);
  }

  async getUserStats(): Promise<UserStats> {
    const result = await this.userRepository.findAll(1, 1000);
    const users = result.users;

    const totalUsers = users.length;
    const activeUsers = users.filter(user => user.isActive).length;
    const inactiveUsers = totalUsers - activeUsers;
    const adminUsers = users.filter(user => user.role === 'admin').length;
    const regularUsers = users.filter(user => user.role === 'user').length;

    return {
      totalUsers,
      activeUsers,
      inactiveUsers,
      adminUsers,
      regularUsers,
    };
  }
}
