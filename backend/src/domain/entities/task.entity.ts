export interface Task {
  id: string;
  title: string;
  description: string;
  status: 'Pending' | 'In Progress' | 'Completed' | 'Cancelled';
  dueDate: Date;
  userId: string;
  assignedTo: string;
  createdAt: Date;
  updatedAt: Date;
  completedAt?: Date;
  attachments?: string[];
  priority?: 'Low' | 'Medium' | 'High';
  tags?: string[];
}

export class TaskEntity {
  constructor(
    public readonly id: string,
    public readonly title: string,
    public readonly description: string,
    public readonly status: 'Pending' | 'In Progress' | 'Completed' | 'Cancelled',
    public readonly dueDate: Date,
    public readonly userId: string,
    public readonly assignedTo: string,
    public readonly createdAt: Date = new Date(),
    public readonly updatedAt: Date = new Date(),
    public readonly completedAt?: Date,
    public readonly attachments: string[] = [],
    public readonly priority: 'Low' | 'Medium' | 'High' = 'Medium',
    public readonly tags: string[] = []
  ) {}

  static create(props: Omit<Task, 'id' | 'createdAt' | 'updatedAt' | 'completedAt'>): TaskEntity {
    const now = new Date();
    console.log('Creating TaskEntity with props:', props);
    return new TaskEntity(
      '', // ID will be generated by the repository
      props.title,
      props.description,
      props.status ?? 'Pending',
      new Date(props.dueDate),
      props.userId,
      props.assignedTo,
      now,
      now,
      undefined,
      props.attachments ?? [],
      props.priority ?? 'Medium',
      props.tags ?? []
    );
  }

  markAsCompleted(): TaskEntity {
    return new TaskEntity(
      this.id,
      this.title,
      this.description,
      'Completed',
      this.dueDate,
      this.userId,
      this.assignedTo,
      this.createdAt,
      new Date(),
      new Date(),
      this.attachments,
      this.priority,
      this.tags
    );
  }

  markAsPending(): TaskEntity {
    return new TaskEntity(
      this.id,
      this.title,
      this.description,
      'Pending',
      this.dueDate,
      this.userId,
      this.assignedTo,
      this.createdAt,
      new Date(),
      undefined,
      this.attachments,
      this.priority,
      this.tags
    );
  }

  markAsInProgress(): TaskEntity {
    return new TaskEntity(
      this.id,
      this.title,
      this.description,
      'In Progress',
      this.dueDate,
      this.userId,
      this.assignedTo,
      this.createdAt,
      new Date(),
      undefined,
      this.attachments,
      this.priority,
      this.tags
    );
  }

  markAsCancelled(): TaskEntity {
    return new TaskEntity(
      this.id,
      this.title,
      this.description,
      'Cancelled',
      this.dueDate,
      this.userId,
      this.assignedTo,
      this.createdAt,
      new Date(),
      undefined,
      this.attachments,
      this.priority,
      this.tags
    );
  }

  updateDetails(
    updates: Partial<
      Pick<Task, 'title' | 'description' | 'dueDate' | 'priority' | 'tags' | 'attachments'>
    >
  ): TaskEntity {
    return new TaskEntity(
      this.id,
      updates.title ?? this.title,
      updates.description ?? this.description,
      this.status,
      updates.dueDate ? new Date(updates.dueDate) : this.dueDate,
      this.userId,
      this.assignedTo,
      this.createdAt,
      new Date(),
      this.completedAt,
      updates.attachments ?? this.attachments,
      updates.priority ?? this.priority,
      updates.tags ?? this.tags
    );
  }

  addAttachment(attachmentUrl: string): TaskEntity {
    return new TaskEntity(
      this.id,
      this.title,
      this.description,
      this.status,
      this.dueDate,
      this.userId,
      this.assignedTo,
      this.createdAt,
      new Date(),
      this.completedAt,
      [...this.attachments, attachmentUrl],
      this.priority,
      this.tags
    );
  }

  removeAttachment(attachmentUrl: string): TaskEntity {
    return new TaskEntity(
      this.id,
      this.title,
      this.description,
      this.status,
      this.dueDate,
      this.userId,
      this.assignedTo,
      this.createdAt,
      new Date(),
      this.completedAt,
      this.attachments.filter(url => url !== attachmentUrl),
      this.priority,
      this.tags
    );
  }

  isOverdue(): boolean {
    return this.status === 'Pending' && this.dueDate < new Date();
  }

  isDueSoon(hoursThreshold: number = 24): boolean {
    if (this.status === 'Completed') {
      return false;
    }
    const now = new Date();
    const timeDiff = this.dueDate.getTime() - now.getTime();
    const hoursDiff = timeDiff / (1000 * 3600);
    return hoursDiff <= hoursThreshold && hoursDiff > 0;
  }
}
